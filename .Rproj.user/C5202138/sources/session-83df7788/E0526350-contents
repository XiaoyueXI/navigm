get_Q_GMN_EM <- function(Omega,
                         zeta,
                         beta,
                         tau1,
                         tau2,
                         P,
                         P2,
                         E1,
                         E2,
                         E2_2,
                         E5,
                         S,
                         V,
                         lambda,
                         v0,
                         v1,
                         s1,
                         n0,
                         t02,
                         a,
                         b,
                         n,
                         p,
                         q) {
  eps <- .Machine$double.eps
  bool_up <- upper.tri(Omega)
  theta <- get_theta(beta, V)
  mat_tmp <- get_Alpha(theta, zeta, p)
  
  bool_log_sum_exp <- F
  if (!bool_log_sum_exp) {
    Q <- n * determinant(Omega, logarithm = TRUE)$modulus[1] / 2 -
      sum(S * Omega) / 2 - #= sum(S * t(Omega)) since Omega is symmetric tr(Y^T Y Omega)
      lambda * sum(diag(Omega)) / 2 -
      sum(log(v1) * P[bool_up] + log(v0) * (1 - P[bool_up]))  +
      (p * (p - 1) / 2) * (log(tau1 + eps) / 2) -
      tau1 * sum(Omega[bool_up] ^ 2 * E1[bool_up]) / 2 +
      (a - 1) * log(tau1 + eps) - b * tau1 - # sum of upper off-diag elements
      sum(E2_2[bool_up]) / 2 +
      sum(mat_tmp[bool_up] * E2[bool_up]) -
      sum(mat_tmp[bool_up] ^ 2) / 2 -
      (zeta ^ 2 - 2 * n0 * zeta) / (2 * t02) -
      sum(log(s1) * P2 + log(1) * (1 - P2))  +
      q * log(tau2 + eps) / 2 -
      tau2 * sum(beta ^ 2 * E5) / 2 +
      (a - 1) * log(tau2 + eps) - b * tau2
    return(Q)
  } else{
    tmp <- effective_sum(
      c(
        n * determinant(Omega, logarithm = TRUE)$modulus[1] / 2,
        -effective_sum(S * Omega) / 2 ,
        -lambda * effective_sum(diag(Omega)) / 2,
        -log(v1) * effective_sum(P[bool_up]),
        -log(v0) * effective_sum(1 - P[bool_up]),
        (p * (p - 1) / 2) * (log(tau1 + eps) / 2),
        -tau1 * effective_sum(Omega[bool_up] ^ 2 * E1[bool_up]) / 2,
        (a - 1) * log(tau1 + eps) ,
        -b * tau1,
        -effective_sum(E2_2[bool_up]) / 2,
        effective_sum(mat_tmp[bool_up] * E2[bool_up]),
        -effective_sum(mat_tmp[bool_up] ^ 2) / 2,
        -zeta ^ 2 / (2 * t02),
        (n0 * zeta) / t02,
        -log(s1) * effective_sum(P2),
        -log(1) * effective_sum(1 - P2),
        q * log(tau2 + eps) / 2,
        -tau2 * effective_sum(beta ^ 2 * E5) / 2,
        (a - 1) * log(tau2 + eps) ,
        -b * tau2
      )
    )
    return(tmp)
  }
  # tmp - Q
}


# get_elbo_GMN_VBEM <- function(Omega,
#                               m_delta,
#                               a_tau,
#                               b_tau,
#                               m_tau,
#                               m_log_tau,
#                               mu_zeta,
#                               sig2_inv_zeta,
#                               m2_zeta,
#                               m_gamma,
#                               a_sigma,
#                               b_sigma,
#                               m_log_sig2_inv,
#                               m_sig2_inv,
#                               m2_beta,   
#                               sig2_inv_beta,
#                               m1_alpha,
#                               sum_var_alpha,
#                               S,
#                               V,
#                               E1,
#                               lambda,
#                               v0,
#                               v1,
#                               n0,
#                               t02,
#                               a, 
#                               b,
#                               n,
#                               p,
#                               q) {
#   eps <- .Machine$double.eps
#   bool_up <- upper.tri(Omega)
#   bool_nonzero <- bool_up & E1 != 0
#   
#   
#     n * determinant(Omega, logarithm = TRUE)$modulus[1] / 2 -
#       sum(S * Omega) / 2 -
#       lambda * sum(diag(Omega)) / 2 -
#       log(v1) * exp(log_sum_exp(log(m_delta[bool_up & m_delta!=0]))) -
#       log(v0) * exp(log_sum_exp(log(1 - m_delta[bool_up & m_delta!=1]))) -
#       m_tau * ( exp(log_sum_exp(2 * log(abs(Omega[bool_nonzero]) + eps) + log(E1[bool_nonzero])))/2 + b - b_tau) +
#       m_log_tau * (p * (p-1)/4 + a - a_tau) -
#       sum_var_alpha/2 -
#       m2_zeta/(2 * t02) +
#       n0 * mu_zeta/t02 +
#       (sum(m_gamma)/2 + a - a_sigma) * m_log_sig2_inv -
#       (exp(log_sum_exp(log(m_gamma[m2_beta!=0]) + log(m2_beta[m2_beta!=0] + eps)))/2 + b - b_sigma) * m_sig2_inv +
#       # ent z
#       sum(m_delta[bool_up] * pnorm(m1_alpha[bool_up], log.p = T, lower.tail = T)) +
#       sum((1-m_delta[bool_up]) * pnorm(m1_alpha[bool_up], log.p = T, lower.tail = F)) -
#       # ent m_delta
#       sum(m_delta[bool_up] * log(m_delta[bool_up] + eps))-
#       sum((1-m_delta[bool_up]) * log(1-m_delta[bool_up] + eps))+
#       # ent zeta
#       (1 + log(2 * pi * sig2_inv_zeta^(-1) + eps))/2 +
#       # ent beta
#       sum(m_gamma * (1 + log(2 * pi * sig2_inv_beta^(-1) + eps))/2 ) -
#       # ent tau
#       a_tau * log(b_tau + eps) + lgamma(a_tau) -
#       # ent sigma
#       a_sigma * log(b_sigma + eps) + lgamma(a_sigma)
# 
# }

get_elbo_GMN_VBEM <- function(Omega,
                              m_delta,
                              a_tau,
                              b_tau,
                              m_tau,
                              m_log_tau,
                              mu_zeta,
                              sig2_inv_zeta,
                              m2_zeta,
                              m_gamma,
                              a_sigma,
                              b_sigma,
                              m_log_sig2_inv,
                              m_sig2_inv,
                              m2_beta,
                              sig2_inv_beta,
                              m1_alpha,
                              sum_var_alpha,
                              S,
                              V,
                              E1,
                              lambda,
                              v0,
                              v1,
                              n0,
                              t02,
                              a,
                              b,
                              n,
                              p,
                              q) {
  eps <- .Machine$double.eps
  bool_up <- upper.tri(Omega)

  bool_log_sum_exp <- F
  if (!bool_log_sum_exp){
    n * determinant(Omega, logarithm = TRUE)$modulus[1] / 2 -
      sum(S * Omega) / 2 -
      lambda * sum(diag(Omega)) / 2 -
      log(v1) * sum(m_delta[bool_up]) -
      log(v0) * sum(1-m_delta[bool_up]) -
      m_tau * (sum(Omega[bool_up]^2 * E1[bool_up])/2 + b - b_tau) +
      m_log_tau * (p * (p-1)/4 + a - a_tau) -
      sum_var_alpha/2 -
      m2_zeta/(2 * t02) +
      n0 * mu_zeta/t02 +
      (sum(m_gamma)/2 + a - a_sigma) * m_log_sig2_inv -
      (sum(m_gamma * m2_beta)/2 + b - b_sigma) * m_sig2_inv +
      # ent z
      sum(m_delta[bool_up] * pnorm(m1_alpha[bool_up], log.p = T, lower.tail = T)) +
      sum((1-m_delta[bool_up]) * pnorm(m1_alpha[bool_up], log.p = T, lower.tail = F)) -
      # ent m_delta
      sum(m_delta[bool_up] * log(m_delta[bool_up] + eps))-
      sum((1-m_delta[bool_up]) * log(1-m_delta[bool_up] + eps))+
      # ent zeta
      (1 + log(2 * pi * sig2_inv_zeta^(-1) + eps))/2 +
      # ent beta
      sum(m_gamma * (1 + log(2 * pi * sig2_inv_beta^(-1) + eps))/2 ) -
      # ent tau
      a_tau * log(b_tau + eps) + lgamma(a_tau) -
      # ent sigma
      a_sigma * log(b_sigma + eps) + lgamma(a_sigma)
  } else {
    effective_sum(c(
      n * determinant(Omega, logarithm = TRUE)$modulus[1] / 2,
      - sum(S * Omega) / 2,
      -  lambda * sum(diag(Omega)) / 2,
      -  log(v1) * sum(m_delta[bool_up]),
      - log(v0) * sum(1-m_delta[bool_up]),
      m_tau * (effective_sum(Omega[bool_up]^2 * E1[bool_up])/2 + b - b_tau),
      m_log_tau * (p * (p-1)/4 + a - a_tau),
      - sum_var_alpha/2,
      - m2_zeta/(2 * t02),
      n0 * mu_zeta/t02,
      (effective_sum(m_gamma)/2 + a - a_sigma) * m_log_sig2_inv,
      (effective_sum(m_gamma * m2_beta)/2 + b - b_sigma) * m_sig2_inv,
      effective_sum(m_delta[bool_up] * pnorm(m1_alpha[bool_up], log.p = T, lower.tail = T)),
      effective_sum((1-m_delta[bool_up]) * pnorm(m1_alpha[bool_up], log.p = T, lower.tail = F)),
      -sum(m_delta[bool_up] * log(m_delta[bool_up] + eps)),
      -sum((1-m_delta[bool_up]) * log(1-m_delta[bool_up] + eps)),
      (1 + log(2 * pi * sig2_inv_zeta^(-1) + eps))/2,
      effective_sum(m_gamma * (1 + log(2 * pi * sig2_inv_beta^(-1) + eps))/2 ),
      - a_tau * log(b_tau + eps),
      lgamma(a_tau),
      - a_sigma * log(b_sigma + eps),
      lgamma(a_sigma)
    ))
  }
}




get_elbo_GMN_VBEM_annealing <- function(Omega,
                              m_delta,
                              a_tau,
                              b_tau,
                              m_tau,
                              m_log_tau,
                              mu_zeta,
                              sig2_inv_zeta,
                              m2_zeta,
                              m_gamma,
                              a_sigma,
                              b_sigma,
                              m_log_sig2_inv,
                              m_sig2_inv,
                              m2_beta,
                              sig2_inv_beta,
                              m1_alpha,
                              sum_var_alpha,
                              S,
                              V,
                              E1,
                              lambda,
                              v0,
                              v1,
                              n0,
                              t02,
                              a,
                              b,
                              n,
                              p,
                              q,
                              c) {
  eps <- .Machine$double.eps
  bool_up <- upper.tri(Omega)
  
  bool_log_sum_exp <- F
  if (!bool_log_sum_exp){
    c * (n * determinant(Omega, logarithm = TRUE)$modulus[1] / 2 -
      sum(S * Omega) / 2 -
      lambda * sum(diag(Omega)) / 2 -
      log(v1) * sum(m_delta[bool_up]) -
      log(v0) * sum(1-m_delta[bool_up]) -
      m_tau * (sum(Omega[bool_up]^2 * E1[bool_up])/2 + b - b_tau) +
      m_log_tau * (p * (p-1)/4 + a - a_tau) -
      sum_var_alpha/2 -
      m2_zeta/(2 * t02) +
      n0 * mu_zeta/t02 +
      (sum(m_gamma)/2 + a - a_sigma) * m_log_sig2_inv -
      (sum(m_gamma * m2_beta)/2 + b - b_sigma) * m_sig2_inv )+
      # ent z
      sum(m_delta[bool_up] * pnorm(sqrt(c) * m1_alpha[bool_up], log.p = T, lower.tail = T)) +
      sum((1-m_delta[bool_up]) * pnorm(sqrt(c) * m1_alpha[bool_up], log.p = T, lower.tail = F)) -
      # ent m_delta
      sum(m_delta[bool_up] * log(m_delta[bool_up] + eps))-
      sum((1-m_delta[bool_up]) * log(1-m_delta[bool_up] + eps))+
      # ent zeta
      (1 + log(2 * pi * sig2_inv_zeta^(-1) + eps))/2 +
      # ent beta
      sum(m_gamma * (1 + log(2 * pi * sig2_inv_beta^(-1) + eps))/2 ) -
      # ent tau
      a_tau * log(b_tau + eps) + lgamma(a_tau) -
      # ent sigma
      a_sigma * log(b_sigma + eps) + lgamma(a_sigma)
  }
}