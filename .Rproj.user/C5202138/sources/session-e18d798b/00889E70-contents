# This file is part of the `navigm` R package:
#     https://github.com/XiaoyueXI/navigm


#' Node-level auxiliary variable informed Gaussian spike-and-slab with model selection.
#'
#' This function performs simultaneous Gaussian spike-and-slab inference and node-level auxiliary variable selections.
#' The continuous spike-and-slab priors require exploring a grid of spike variance and selecting model.
#'
#' @param Y Data matrix of dimension N x P, where N is the number of samples and P is the number of nodes in the graph.
#'   \code{Y} will be centred within \code{navigm} call.
#'
#' @param V Input matrix of dimension P x Q, where Q is the number of candidate auxiliary variables. No need to supply intercept.
#'   If \code{V} is not specified, set \code{method = 'GM'}.
#'
#' @param list_hyper A list containing the model hyperparameters:
#'   the gamma prior on the continuous spike-and-slab scale requires shape parameter \code{a_tau} and rate parameter \code{b_tau};
#'   the unscaled slab variances in the continuous spike-and-slab is \code{v1};
#'   a grid of unscaled spike variances in the continuous spike-and-slab is \code{vec_v0};
#'   the exponential prior on diagonal entries requires rate parameter \code{lambda};
#'   the normal prior on the overall sparsity requires mean \code{n0} and variance \code{t02};
#'   the gamma prior on the slab precision in the discrete spike-and-slab requires shape parameter \code{a_sigma} and rate parameter \code{b_sigma} (needed in GMN & GMSS);
#'   the beta prior on auxiliary variable inclusion probability requires shape parameters \code{a_o} and \code{b_o} (only needed in GMSS);
#'   the beta prior on edge inclusion probability requires shape parameters \code{a_rho} and \code{b_rho} (only needed in \code{method = "GM"} and \code{version = 1});
#'
#'   if NULL or any hyperparameter specification is missing,
#'   set to default, \code{lambda = 2, vec_v0 = seq(1e-4, 1, length.out = 16), v1 = 100, a_tau = b_tau = a_sigma = b_sigma = 2},
#'   \code{n0 = -2, t02 = 0.5, a_o = 1, b_o = Q, a_rho = 1, b_rho = P}.
#'
#'  @param ne0 Vector of length 2 whose entries are the prior expectation and variance of
#'  the number of edges in absence of hubs. Will not be used if \code{n0} in \code{list_hyper} is non-\code{NULL}.
#'
#' @param list_init A list containing the initial variational parameters if \code{inference = 'VBEM'}:
#'  the gamma variational distribution of the continuous spike-and-slab scale includes shape parameter \code{alpha_tau} and rate parameter \code{beta_tau};
#'  the normal variational distribution of the overall sparsity includes mean \code{mu_zeta} and variance \code{sig2_inv_zeta};
#'  the normal variational distribution of regression coefficients includes mean \code{mu_beta} and variance \code{sig2_inv_beta} (needed in GMN & GMSS);
#'  the gamma variational distribution of slab precision in the discrete spike-and-slab includes \code{alpha_sigma, beta_sigma} (needed in GMN & GMSS);
#'  the beta variational distribution of auxiliary variable inclusion probability includes \code{alpha_o} and \code{beta_o} (only needed in GMSS);
#'  the beta variational distribution of edge inclusion probability includes \code{alpha_rho} and \code{beta_rho} (only needed in \code{method = "GM"} and \code{version = 1});
#'  if \code{NULL} or any initialisations are missing,
#'  set to default, \code{mu_beta}: vector of zeros, \code{sig2_inv_beta}: vector of ones,
#'  \code{alpha_tau = beta_tau = alpha_sigma = beta_sigma = 1}, \code{mu_zeta = list_hyper$n0},
#'  \code{sig2_inv_zeta = 1/list_hyper$t02}, \code{a_o = 1, b_o = Q},  \code{a_rho = 1, b_rho = P}.
#'  A list containing the initial parameters if \code{inference = 'EM'}:
#'  the continuous spike-and-slab scale in the level of edge selection \code{tau_1};
#'  the overall sparsity \code{zeta};
#'  the regression coefficients \code{beta} (needed in GMN & GMSS);
#'  the continuous spike-and-slab scale in the level of auxiliary variable selection \code{tau_2} (needed in GMN & GMSS);
#'  the auxiliary variable inclusion probability \code{o} (only needed in GMSS);
#'  if \code{NULL} or any initialisation is missing,
#'  set to default, \code{beta}: vector of zeros, \code{tau_1 = tau_2 = 1}, \code{zeta = list_hyper$n0}, \code{o = 1 / Q}, \code{rho = 1 / P}.
#'
#'  @param method Character: the method to be used, including
#'  'GM' (vanilla spike-and-slab graphical model),
#'  'GMN' (spike-and-slab graphical model with normal prior for the node-level auxiliary variable coefficients), and
#'  'GMSS' (default; spike-and-slab graphical model with spike-and-slab prior for the node-level auxiliary variable coefficients).
#'
#'  @param criterion Character: the model selection criterion to be used, including
#'  'AIC' (default), 'BIC' and 'EBIC'.
#'
#'  @param inference Character: the inference algorithm to be used, including
#'  'EM' (expectation maximisation algorithm),
#'  'VBEM' (default; variational Bayes expectation maximisation algorithm),
#'
#'  @param tol Scalar: tolerance for the stopping criterion (default is 0.1).
#'
#'  @param maxit Scalar: maximum number of iterations allowed (default is 1000).
#'
#'  @param transformV Logical; if \code{FALSE} (default), \code{V} will not be transformed;
#'  Otherwise and if \code{V} does not range within [0,1],  \code{V} will be standardised within \code{navigm} call.
#'
#'  @param verbose Logical; if \code{TRUE} (default), standard verbosity; otherwise, no messages.
#'
#'  @param track_ELBO Logical; if \code{TRUE} (default), track ELBO after each maximisation step; otherwise, not track.
#'
#'  @param debug Logical; if \code{FALSE} (default), not record additional terms for the purpose of debug;
#'  otherwise, record the number of decreasing ELBOs in the maximisation step, possibly due to numerical round-off;
#'  and ELBOs and number of decreasing ELBOs within each variational update (only in the VBEM).
#'
#'  @param version Integer; take values of 1 (a beta prior on edge inclusion) or 2 (a normal prior on probit edge inclusion) only.
#'  Only valid when \code{method = 'GM'}.
#'
#'  @param full_output Logical; if \code{FALSE}, the estimation for the selected model is returned.
#'  Otherwise, the estimations are returned for all the explored models.
#'
#'  @param numCores number of cores for parallel computation.
#'
#'  @details \code{navigm} implements a Gaussian graphical model
#'   that allows incorporating and selecting node-level auxiliary variables,
#'   thereby enhancing the detection of conditional dependence. Inference is
#'   carried out using a scalable (variational) expectation maximisation
#'   algorithm, which is applicable to high-dimension graphs.
#'
#'
#' @return A list containing the following estimates and settings:
#'  \describe{
#'  \item{estimates}{A list containing estimates of variational distribution parameters, which includes a selection of following terms depending on method:
#'  \code{Omega} (estimated precision matrix of dimension P x P),
#'  \code{m_delta} (VBEM), \code{P1} (EM) (posterior inclusion probability matrix of dimension P x P. off-diagonal entry (i, j) corresponds to
#'  the variational posterior probability of edge (i,j) being included in the graph),
#'  \code{m_gamma} (VBEM), \code{P2} (EM) (posterior inclusion probability vector of dimension Q. entry Q corresponds to the variational posterior probability of
#'           qth auxiliary variable explaining the node centrality in GMSS),
#'  \code{mu_beta, sig2_inv_beta} (VBEM) (vector of length Q containing the variational posterior mean and inverse variance of regression coefficients of
#'           node-level auxiliary variables in columns of matrix \code{V} in GMN and GMSS),
#' \code{a_tau, b_tau} (VBEM) (estimated parameters of Gamma distributed scale in continuous spike-and-slab),
#' \code{a_sigma, b_sigma} (VBEM) (estimated parameters of Gamma distributed slab variance in discrete spike-and-slab in GMN and GMSS,
#' \code{a_o, b_o} (VBEM) (estimated parameters of Beta distributed auxiliary variable inclusion probability in GMSS),
#' \code{mu_zeta, sig2_inv_zeta} (VBEM) (variational posterior mean and inverse variance of overall sparsity parameter except for \code{GM version = 1} ).
#' \code{beta} (EM) (vector of length Q containing the estimated regression coefficients of
#'           node-level auxiliary variables in columns of matrix \code{V} in GMN and GMSS),
#' \code{tau_1} (EM) (estimated edge-level continuous spike-and-slab scale),
#' \code{tau_2} (EM) (estimated variable-level continuous spike-and-slab scale in GMN and GMSS),
#' \code{o} (EM) (estimated auxiliary variable inclusion probability in GMSS),
#' \code{zeta} (EM) (estimated overall sparsity parameter except for \code{GM version = 1}).}
#}
#'  \item{debugs}{A list containing terms for debugging:
#'  \code{n_warning} (scalar. number of ELBO drops in the maximisation step),
#'  \code{vec_n_warning_VB} (vector of length \code{it}. number of ELBO drops in each variational step. Only in VBEM),
#'  \code{list_elbo} (a list of length \code{it} containing the ELBO in each variational step. Only in VBEM).  }
#'  \item{args}{A list containing the algorithm inputs including \code{list_hyper} and \code{list_init}.}
#' \item{it}{Scalar. Final number of iterations. \code{it == maxit} indicates the algorithm dose not converge. }
#' \item{vec_ELBO_M}{Vector of length \code{it}. ELBOs after the maximisation step. }
#' \item{vec_VB_it}{Vector of length \code{it}. Number of iterations in each variational step.
#' \code{any(vec_VB_it == maxit)} indicates the variational step dose not converge. Only in VBEM.}
#' \item{full_outputs}{A list containing outputs for all the explored models.}
#' \item{pt}{Scalar. Algorithm runtime in seconds. }
#' \item{index}{Integer. Index of spike variance selected.}
#' \item{criterion}{Character. Input model selection criterion. }
#' \item{vec_criterion}{Vector with the same length of list_hypr$v0_v. Evaluation of model selection criterion on a grid of spike variance. }
#' \item{total_pt}{Total runtime of algorithm in seconds, including parallel implemntation of candidate models and model selection. }
#' }
#'
#' @examples
#' # simulate data
#'
#' seed <- 123; set.seed(seed)
#' N <- 100; P <- 5; Q <- 3
#' V <- matrix(rnorm(P*Q), nrow = P, ncol = Q)
#' Y <- matrix(rnorm(N*P), nrow = N, ncol = P)
#'
#' # estimate precision matrix based on Y and meanwhile leverage node-level variables V
#' res_navigm <- navigm(Y, V, numCores = 2)
#' # res_navigm <- navigm(Y, V, method = 'GMN')
#' # res_navigm <- navigm(Y, V, method = 'GM', version = 1)
#' # res_navigm <- navigm(Y, V, method = 'GM', version = 2)
#' # res_navigm <- navigm(Y, V, inference = 'EM')
#' # res_navigm <- navigm(Y, V, method = 'GMN', inference = 'EM')
#' # res_navigm <- navigm(Y, V, method = 'GM', inference = 'EM', version = 1)
#' # res_navigm <- navigm(Y, V, method = 'GM', inference = 'EM', version = 2)
#'
#' @import doParallel parallel foreach matrixcalc
#' @export
#'


navigm <- function(Y, V =NULL,
                    method = 'GMSS',
                    inference = 'VBEM',
                    criterion = 'AIC',
                    list_hyper = NULL, list_init = NULL,
                    ne0 = NULL,
                    tol = 0.1, maxit = 1000,
                    verbose = T,
                    track_ELBO = F, debug = F,
                    version = NULL,
                   numCores = NULL,
                    # transformY = T,# as mean is 0, always centre Y
                    transformV = F,
                    full_output = F) {

  # Time
  #
  pt <- Sys.time()

  # Set up
  #
  if(is.null(numCores)){
    numCores <- detectCores()
  }
  registerDoParallel(numCores)

  #

  list_hyper <- set_default(list_hyper, 'v0_v', seq(1e-4,  1, length.out = 16))
  if(any(list_hyper$vec_v0 <= 0))stop("all the entries of vec_v0 must be positive.")

  if(method =='GMSS' & inference == 'EM'){
    list_hyper <- set_default(list_hyper, 's0_v', seq(1e-4,  1, length.out = 16))
    if(any(list_hyper$vec_s0 <= 0))stop("all the entries of vec_s0 must be positive.")
  }

  #
  if (verbose) cat("== Parallel exploration of a", ifelse(method =='GMSS' & inference == 'EM', "double", ""),
                   "grid of spike standard deviations \n v0 = ", list_hyper$v0_v, "\n",
                   ifelse(method =='GMSS' & inference == 'EM',paste0("and s0 = ", paste(list_hyper$s0_v, collapse = ' '), '\n') , ""),
                   "on ",numCores," cores ... \n\n")

  # keep all the checks & steps inside navigm_core
  # to make it work standalone
  #
  if(!(method =='GMSS' & inference == 'EM')){
    out <- foreach (v0 = list_hyper$v0_v) %dopar% {
      list_hyper$v0 <- v0
      navigm_core(Y = Y,
                   V = V,
                   method = method,
                   inference = inference,
                   list_hyper = list_hyper,
                   list_init = list_init,
                   ne0 = ne0,
                   tol = tol,
                   maxit = maxit,
                   verbose = verbose,
                   track_ELBO = track_ELBO,
                   debug = debug,
                   version = version,
                   transformV = transformV)
    }
  }else{
    out <- foreach (v0 = list_hyper$v0_v) %:%
      foreach(s0 = list_hyper$s0_v)%dopar% {
        list_hyper$v0 <- v0
        list_hyper$s0 <- s0
        navigm_core(Y = Y,
                     V = V,
                     method = method,
                     inference = inference,
                     list_hyper = list_hyper,
                     list_init = list_init,
                     ne0 = ne0,
                     tol = tol,
                     maxit = maxit,
                     verbose = verbose,
                     track_ELBO = track_ELBO,
                     debug = debug,
                     version = version,
                     transformV = transformV)
      }
  }


  if (verbose) cat("... done. == \n\n")

  if (verbose) cat("== Select from a grid of spike variance using",criterion," ... \n\n")

  if(criterion == 'AIC'){

    if(!(method =='GMSS' & inference == 'EM')){
      vec_criterion <- sapply(out, function(x){AIC_GSS(x$estimates,N = nrow(x$args$Y))})
    }else{
      vec_criterion <- do.call('rbind',lapply(out, function(x){
        sapply(x, function(y){
          AIC_GSS(y$estimates,N = nrow(y$args$Y))
        })
      }))}


  }else if(criterion == 'BIC'){

    if(!(method =='GMSS' & inference == 'EM')){
      vec_criterion <- sapply(out, function(x){BIC_GSS(x$estimates,N = nrow(x$args$Y))})
    }else{
      vec_criterion <- do.call('rbind',lapply(out, function(x){
        sapply(x, function(y){
          BIC_GSS(y$estimates,N = nrow(y$args$Y))
        })
      }))
    }

  }else if(criterion == 'EBIC'){


    if(!(method =='GMSS' & inference == 'EM')){
      vec_criterion <- sapply(out, function(x){EBIC_GSS(x$estimates,
                                                        N = nrow(x$args$Y),
                                                        P = ncol(x$args$Y))})
    }else{
      vec_criterion <- do.call('rbind',lapply(out, function(x){
        sapply(x, function(y){
          EBIC_GSS(y$estimates,
                   N = nrow(y$args$Y),
                   P = ncol(x$args$Y))
        })
      }))
    }

  }
  if(!(method =='GMSS' & inference == 'EM')){

    index <- which.min(vec_criterion)

    if(index == 1){
      warning('The selected v0 reaches the lower bound in the grid. Consider extend the grid to lower values. ')
    }else if(index == length(list_hyper$v0_v)){
      warning('The selected v0 reaches the upper bound in the grid. Consider extend the grid to higher values. ')
    }

  }else{

    index <- which(vec_criterion == min(vec_criterion), arr.ind = TRUE)

    if(length(index) != 2){
      warning('More than one best index choices \n')
      if(verbose){
        cat('These indices are all equally the best: \n')
        print(index)
      }
      index <- index[1,]
    }

    if(index[1] == 1){
      warning('The selected v0 reaches the lower bound in the grid. Consider extend the grid to lower values. ')
    }else if(index[1] == length(list_hyper$v0_v)){
      warning('The selected v0 reaches the upper bound in the grid. Consider extend the grid to higher values. ')
    }
    if(index[2] == 1){
      warning('The selected s0 reaches the lower bound in the grid. Consider extend the grid to lower values. ')
    }else if(index[2] == length(list_hyper$s0_v)){
      warning('The selected s0 reaches the upper bound in the grid. Consider extend the grid to higher values. ')
    }
  }



  if (verbose) cat("... done. == \n\n")

  if(!(method =='GMSS' & inference == 'EM')){
    if(verbose) cat("Select the index", index, " i.e., v0 = ", list_hyper$v0_v[index], ", the best",criterion, " = ", vec_criterion[index], '.\n\n')
  }else{
    if(verbose) cat("Select the index", index, " i.e., v0 = ", list_hyper$v0_v[index[1]] ," and s0 = ", list_hyper$s0_v[index[2]], ",the best",criterion, " = ", vec_criterion[index[1], index[2]], '.\n\n')
  }
  pt <- Sys.time() - pt
  cat('Total runtime: ',format(pt), '.\n')

  if(!(method =='GMSS' & inference == 'EM')){

    ans <- out[[index]]
  }else{
    ans <- out[[index[1]]][[index[2]]]
  }
  ans <- c(ans,
           list(
             index = index,
             criterion = criterion,
             vec_criterion = vec_criterion,
             total_pt = pt
           ))


  if(full_output){

    ans$full_output <- out

  }

  return(ans)
}


