% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/navigm.R
\name{navigm}
\alias{navigm}
\title{Node-level auxiliary variable informed Gaussian spike-and-slab with model selection.}
\usage{
navigm(
  Y,
  V = NULL,
  method = "GMSS",
  inference = "VBEM",
  criterion = "AIC",
  list_hyper = NULL,
  list_init = NULL,
  ne0 = NULL,
  tol = 0.1,
  maxit = 1000,
  verbose = T,
  track_ELBO = F,
  debug = F,
  version = NULL,
  numCores = NULL,
  transformV = F,
  full_output = F
)
}
\arguments{
\item{Y}{Data matrix of dimension N x P, where N is the number of samples and P is the number of nodes in the graph.
\code{Y} will be centred within \code{navigm} call.}

\item{V}{Input matrix of dimension P x Q, where Q is the number of candidate auxiliary variables. No need to supply intercept.
If \code{V} is not specified, set \code{method = 'GM'}.}

\item{list_hyper}{A list containing the model hyperparameters:
  the gamma prior on the continuous spike-and-slab scale requires shape parameter \code{a_tau} and rate parameter \code{b_tau};
  the unscaled slab variances in the continuous spike-and-slab is \code{v1};
  a grid of unscaled spike variances in the continuous spike-and-slab is \code{vec_v0};
  the exponential prior on diagonal entries requires rate parameter \code{lambda};
  the normal prior on the overall sparsity requires mean \code{n0} and variance \code{t02};
  the gamma prior on the slab precision in the discrete spike-and-slab requires shape parameter \code{a_sigma} and rate parameter \code{b_sigma} (needed in GMN & GMSS);
  the beta prior on auxiliary variable inclusion probability requires shape parameters \code{a_o} and \code{b_o} (only needed in GMSS);
  the beta prior on edge inclusion probability requires shape parameters \code{a_rho} and \code{b_rho} (only needed in \code{method = "GM"} and \code{version = 1});

  if NULL or any hyperparameter specification is missing,
  set to default, \code{lambda = 2, vec_v0 = seq(1e-4, 1, length.out = 16), v1 = 100, a_tau = b_tau = a_sigma = b_sigma = 2},
  \code{n0 = -2, t02 = 0.5, a_o = 1, b_o = Q, a_rho = 1, b_rho = P}.

 @param ne0 Vector of length 2 whose entries are the prior expectation and variance of
 the number of edges in absence of hubs. Will not be used if \code{n0} in \code{list_hyper} is non-\code{NULL}.}

\item{list_init}{A list containing the initial variational parameters if \code{inference = 'VBEM'}:
 the gamma variational distribution of the continuous spike-and-slab scale includes shape parameter \code{alpha_tau} and rate parameter \code{beta_tau};
 the normal variational distribution of the overall sparsity includes mean \code{mu_zeta} and variance \code{sig2_inv_zeta};
 the normal variational distribution of regression coefficients includes mean \code{mu_beta} and variance \code{sig2_inv_beta} (needed in GMN & GMSS);
 the gamma variational distribution of slab precision in the discrete spike-and-slab includes \code{alpha_sigma, beta_sigma} (needed in GMN & GMSS);
 the beta variational distribution of auxiliary variable inclusion probability includes \code{alpha_o} and \code{beta_o} (only needed in GMSS);
 the beta variational distribution of edge inclusion probability includes \code{alpha_rho} and \code{beta_rho} (only needed in \code{method = "GM"} and \code{version = 1});
 if \code{NULL} or any initialisations are missing,
 set to default, \code{mu_beta}: vector of zeros, \code{sig2_inv_beta}: vector of ones,
 \code{alpha_tau = beta_tau = alpha_sigma = beta_sigma = 1}, \code{mu_zeta = list_hyper$n0},
 \code{sig2_inv_zeta = 1/list_hyper$t02}, \code{a_o = 1, b_o = Q},  \code{a_rho = 1, b_rho = P}.
 A list containing the initial parameters if \code{inference = 'EM'}:
 the continuous spike-and-slab scale in the level of edge selection \code{tau_1};
 the overall sparsity \code{zeta};
 the regression coefficients \code{beta} (needed in GMN & GMSS);
 the continuous spike-and-slab scale in the level of auxiliary variable selection \code{tau_2} (needed in GMN & GMSS);
 the auxiliary variable inclusion probability \code{o} (only needed in GMSS);
 if \code{NULL} or any initialisation is missing,
 set to default, \code{beta}: vector of zeros, \code{tau_1 = tau_2 = 1}, \code{zeta = list_hyper$n0}, \code{o = 1 / Q}, \code{rho = 1 / P}.

 @param method Character: the method to be used, including
 'GM' (vanilla spike-and-slab graphical model),
 'GMN' (spike-and-slab graphical model with normal prior for the node-level auxiliary variable coefficients), and
 'GMSS' (default; spike-and-slab graphical model with spike-and-slab prior for the node-level auxiliary variable coefficients).

 @param criterion Character: the model selection criterion to be used, including
 'AIC' (default), 'BIC' and 'EBIC'.

 @param inference Character: the inference algorithm to be used, including
 'EM' (expectation maximisation algorithm),
 'VBEM' (default; variational Bayes expectation maximisation algorithm),

 @param tol Scalar: tolerance for the stopping criterion (default is 0.1).

 @param maxit Scalar: maximum number of iterations allowed (default is 1000).

 @param transformV Logical; if \code{FALSE} (default), \code{V} will not be transformed;
 Otherwise and if \code{V} does not range within [0,1],  \code{V} will be standardised within \code{navigm} call.

 @param verbose Logical; if \code{TRUE} (default), standard verbosity; otherwise, no messages.

 @param track_ELBO Logical; if \code{TRUE} (default), track ELBO after each maximisation step; otherwise, not track.

 @param debug Logical; if \code{FALSE} (default), not record additional terms for the purpose of debug;
 otherwise, record the number of decreasing ELBOs in the maximisation step, possibly due to numerical round-off;
 and ELBOs and number of decreasing ELBOs within each variational update (only in the VBEM).

 @param version Integer; take values of 1 (a beta prior on edge inclusion) or 2 (a normal prior on probit edge inclusion) only.
 Only valid when \code{method = 'GM'}.

 @param full_output Logical; if \code{FALSE}, the estimation for the selected model is returned.
 Otherwise, the estimations are returned for all the explored models.

 @param numCores number of cores for parallel computation.

 @details \code{navigm} implements a Gaussian graphical model
  that allows incorporating and selecting node-level auxiliary variables,
  thereby enhancing the detection of conditional dependence. Inference is
  carried out using a scalable (variational) expectation maximisation
  algorithm, which is applicable to high-dimension graphs.}
}
\value{
A list containing the following estimates and settings:
 \describe{
 \item{estimates}{A list containing estimates of variational distribution parameters, which includes a selection of following terms depending on method:
 \code{Omega} (estimated precision matrix of dimension P x P),
 \code{m_delta} (VBEM), \code{P1} (EM) (posterior inclusion probability matrix of dimension P x P. off-diagonal entry (i, j) corresponds to
 the variational posterior probability of edge (i,j) being included in the graph),
 \code{m_gamma} (VBEM), \code{P2} (EM) (posterior inclusion probability vector of dimension Q. entry Q corresponds to the variational posterior probability of
          qth auxiliary variable explaining the node centrality in GMSS),
 \code{mu_beta, sig2_inv_beta} (VBEM) (vector of length Q containing the variational posterior mean and inverse variance of regression coefficients of
          node-level auxiliary variables in columns of matrix \code{V} in GMN and GMSS),
\code{a_tau, b_tau} (VBEM) (estimated parameters of Gamma distributed scale in continuous spike-and-slab),
\code{a_sigma, b_sigma} (VBEM) (estimated parameters of Gamma distributed slab variance in discrete spike-and-slab in GMN and GMSS,
\code{a_o, b_o} (VBEM) (estimated parameters of Beta distributed auxiliary variable inclusion probability in GMSS),
\code{mu_zeta, sig2_inv_zeta} (VBEM) (variational posterior mean and inverse variance of overall sparsity parameter except for \code{GM version = 1} ).
\code{beta} (EM) (vector of length Q containing the estimated regression coefficients of
          node-level auxiliary variables in columns of matrix \code{V} in GMN and GMSS),
\code{tau_1} (EM) (estimated edge-level continuous spike-and-slab scale),
\code{tau_2} (EM) (estimated variable-level continuous spike-and-slab scale in GMN and GMSS),
\code{o} (EM) (estimated auxiliary variable inclusion probability in GMSS),
\code{zeta} (EM) (estimated overall sparsity parameter except for \code{GM version = 1}).}
 \item{debugs}{A list containing terms for debugging:
 \code{n_warning} (scalar. number of ELBO drops in the maximisation step),
 \code{vec_n_warning_VB} (vector of length \code{it}. number of ELBO drops in each variational step. Only in VBEM),
 \code{list_elbo} (a list of length \code{it} containing the ELBO in each variational step. Only in VBEM).  }
 \item{args}{A list containing the algorithm inputs including \code{list_hyper} and \code{list_init}.}
\item{it}{Scalar. Final number of iterations. \code{it == maxit} indicates the algorithm dose not converge. }
\item{vec_ELBO_M}{Vector of length \code{it}. ELBOs after the maximisation step. }
\item{vec_VB_it}{Vector of length \code{it}. Number of iterations in each variational step.
\code{any(vec_VB_it == maxit)} indicates the variational step dose not converge. Only in VBEM.}
\item{full_outputs}{A list containing outputs for all the explored models.}
\item{pt}{Scalar. Algorithm runtime in seconds. }
\item{index}{Integer. Index of spike variance selected.}
\item{criterion}{Character. Input model selection criterion. }
\item{vec_criterion}{Vector with the same length of list_hypr$v0_v. Evaluation of model selection criterion on a grid of spike variance. }
\item{total_pt}{Total runtime of algorithm in seconds, including parallel implemntation of candidate models and model selection. }
}
}
\description{
This function performs simultaneous Gaussian spike-and-slab inference and node-level auxiliary variable selections.
The continuous spike-and-slab priors require exploring a grid of spike variance and selecting model.
}
\examples{
# simulate data

seed <- 123; set.seed(seed)
N <- 100; P <- 5; Q <- 3
V <- matrix(rnorm(P*Q), nrow = P, ncol = Q)
Y <- matrix(rnorm(N*P), nrow = N, ncol = P)

# estimate precision matrix based on Y and meanwhile leverage node-level variables V
res_navigm <- navigm(Y, V, numCores = 2)
# res_navigm <- navigm(Y, V, method = 'GMN')
# res_navigm <- navigm(Y, V, method = 'GM', version = 1)
# res_navigm <- navigm(Y, V, method = 'GM', version = 2)
# res_navigm <- navigm(Y, V, inference = 'EM')
# res_navigm <- navigm(Y, V, method = 'GMN', inference = 'EM')
# res_navigm <- navigm(Y, V, method = 'GM', inference = 'EM', version = 1)
# res_navigm <- navigm(Y, V, method = 'GM', inference = 'EM', version = 2)

}
