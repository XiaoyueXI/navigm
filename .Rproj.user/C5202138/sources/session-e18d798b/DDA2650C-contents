# trunc_perf <-  function(perf, fpr.stop) { # perf = list with multiple entry per replication
#
#   for (iperf in seq_along(perf@x.values)){
#     ind = which(perf@x.values[[iperf]] <= fpr.stop)
#     perf@y.values[[iperf]] = perf@y.values[[iperf]][ind]
#     perf@x.values[[iperf]] = perf@x.values[[iperf]][ind]
#   }
#
#   perf
#
# }


#' @export
AIC_GSS <- function(estimates, N){

  Omega <- estimates$Omega
  Omega[estimates$m_delta <= 0.5] <- 0
  diag(Omega) <- diag(estimates$Omega)

  sum(diag(estimates$S %*% Omega)) -
    N * determinant(Omega, logarithm = TRUE)$modulus[1] +
    2 * sum(estimates$m_delta > 0.5)

}


#' @export
BIC_GSS <- function(estimates, N){

  Omega <- estimates$Omega
  Omega[estimates$m_delta <= 0.5] <- 0
  diag(Omega) <- diag(estimates$Omega)

  sum(diag(estimates$S %*% Omega)) -
    N * determinant(Omega, logarithm = TRUE)$modulus[1] +
    log(N) * sum(estimates$m_delta > 0.5)

}


#' @export
EBIC_GSS <- function(estimates, gamma =0.5, N, P){

  Omega <- estimates$Omega
  Omega[estimates$m_delta <= 0.5] <- 0
  diag(Omega) <- diag(estimates$Omega)

  sum(diag(estimates$S %*% Omega)) -
    N * determinant(Omega, logarithm = TRUE)$modulus[1] +
    (log(N) + 4 * gamma * log(P)) * sum(estimates$m_delta > 0.5)

}

#' @import ROCR
#' @export
plot_roc <- function(ppi, pat, col, lty = 1,
                     add = FALSE, fpr_stop = 1,
                     main = "ROC curves") {

  pred <- ROCR::prediction(ppi,pat)
  perf <- ROCR::performance(pred, measure = "tpr", x.measure = "fpr")

  plot(perf, col = col, type = "l", lwd = 2, lty = lty,
       main = main, add = add, xlim = c(0,fpr_stop), ylim = c(0, 1),
       avg= "vertical", spread.estimate="stderror", spread.scale = 2,
       show.spread.at = seq(0,fpr_stop,length.out= 11))

}


#' @import ROCR
#' @export
compute_pauc <- function(ppi, pat,  fpr_stop = 1, standardise = F) {

  pred <- ROCR::prediction(ppi,pat)
  perf <- performance(pred, measure = 'auc',fpr.stop = fpr_stop)
  pauc <- do.call('c',perf@y.values)

  if(standardise){
    # https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3744586/
    pauc <- (1 + (pauc - fpr_stop^2/2)/(fpr_stop - fpr_stop^2/2))/2
  }

  return(pauc)

}


#' @export
plot_ppi <- function(ppi, ppi_names = NULL, col ='black', condition = (ppi >=0.5),
                     xlab = 'auxiliary variables', ylab = 'effect sizes',...){

  if(is.null(ppi_names)){
    ppi_names <- 1:length(ppi)
  }
  plot(ppi_names, ppi, col = col,
       pch = 19, xlab = xlab, ylab = ylab, ...)

  segments(which(condition), rep(0,sum(condition)), x1 = which(condition), y1 = ppi[condition])

}


#' @export
compute_perf <- function(ppi, pat, threshold){

  pat <- as.logical(pat)
  tpr <- sum(ppi >= 0.5 & pat)/sum(pat)
  fpr <- sum(ppi >= 0.5 & !pat)/sum(!pat)
  fnr <- sum(ppi < 0.5 & pat)/sum(pat)
  tnr <- sum(ppi < 0.5 & !pat)/sum(!pat)

  recall <- tpr
  precision <-  sum(ppi >= 0.5 & pat)/sum(ppi >= 0.5)
  f1 <- 2 * (precision * recall) / (precision + recall)

  create_named_list_(tpr, fpr, tnr, fnr, recall, precision, f1)

}


#' @import igraph
#' @export
plot_network <- function(x, cex = 0.5, node_names = NULL){

  x <- x == 1
  diag(x) <- F
  if(is.null(node_names)){
    node_names <- rownames(x)
  }
  g <- graph_from_adjacency_matrix(x, mode="undirected")
  lay <- layout_in_circle(g)
  V(g)$label.cex <- cex
  pg <- plot(g, layout=lay, vertex.color="yellow", vertex.label = node_names)

  return(pg)

}
